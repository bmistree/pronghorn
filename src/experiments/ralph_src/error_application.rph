#include 'iapplication.rph'
alias Interface IApplication as 'pronghorn.IApplicationJava.IApplication';

#include 'instance.rph'
alias Service Instance as 'pronghorn.InstanceJava.Instance';

#include 'wrapped_switch.rph'
alias Struct StructWrappedSwitch as 'pronghorn.WrappedSwitchJava.StructWrappedSwitch';

alias Interface IErrorApplication as 'experiments.IErrorApplicationJava.IErrorApplication';

Service ErrorApplication
    implements Interface IApplication, Interface IErrorApplication
{
    Service Instance inst = null;
    TVar Map(from: Text, to: Struct StructWrappedSwitch) switch_map;
    TVar Number coarse_lock_simulator = 0;

    
    // @Override --- from IApplication interface
    init(Service Instance inst_,
        TVar Map(from: Text, to: Struct StructWrappedSwitch) switch_map_)
    {
        inst = inst_;
        switch_map = switch_map_;
    }

    // @Override --- from IApplication interface; do nothing when
    // first installed
    run()
    {}

    // @Override --- from IErrorApplication
    num_flow_table_entries(Text switch_id) returns Number
    {
        Number to_return;
        atomically
        {
            Struct StructWrappedSwitch sws = switch_map.get(switch_id);
            to_return = sws.wrapped_switch.ftable_size();
        }
        return to_return;
    }
    // @Override --- from IErrorApplication
    block_traffic_all_switches()
    {
        atomically
        {
            // insert a rule to block all traffic on all ports
            for (Text switch_id in switch_map)
            {

                Struct MatchField match_field_ip_src;
                match_field_ip_src.field_name = 'nw_src';
                match_field_ip_src.value = '18.18.18.18';

                Struct MatchField match_field_ip_dst;
                match_field_ip_dst.field_name = 'nw_dst';
                match_field_ip_dst.value = '18.18.18.19';

                Struct Match match;
                match.all_matches.append(match_field_ip_src);
                match.all_matches.append(match_field_ip_dst);

                // add drop instruction
                Struct InstructionApplyActions drop_action;
                Struct Instructions instructions;
                instructions.apply_actions = drop_action;

                // genreate entry from matches and instruction
                Struct FlowTableEntry entry_to_add;
                entry_to_add.match = match;
                entry_to_add.instructions = instructions;

                Struct StructWrappedSwitch sws = switch_map.get(switch_id);
                sws.wrapped_switch.add_entry(entry_to_add);
            }
        }
    }
    // @Override --- from IErrorApplication
    remove_first_entry_all_switches()
    {
        atomically
        {
            // remove the rule to block traffic on all ports.
            for (Text switch_id in switch_map)
            {
                Struct StructWrappedSwitch sws = switch_map.get(switch_id);
                if (sws.wrapped_switch.ftable_size() != 0)
                    sws.wrapped_switch.remove_entry(0);
            }
        }
    }

    // @Override --- from IErrorApplication
    logical_clear_switch_do_not_flush_clear_to_hardware(Text switch_id)
    {
        atomically
        {
            Struct StructWrappedSwitch sws = switch_map.get(switch_id);
            sws.wrapped_switch.logical_clear_switch_do_not_flush_clear_to_hardware();
        }
    }
}

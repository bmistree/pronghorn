#include 'iapplication.rph'
alias Interface IApplication as 'pronghorn.IApplicationJava.IApplication';

#include 'wrapped_switch.rph'
alias Struct StructWrappedSwitch as 'pronghorn.WrappedSwitchJava.StructWrappedSwitch';

alias Service Instance as 'pronghorn.InstanceJava.Instance';

// NOTE: Presupposes that two switches are connected.
// Calling event1 performs a read on switch s1 and a write on switch s2.
// Calling event2 does the opposite.  With speculation turned on, should be able
// to run concurrently.  With speculation turned off, should not be able to run
// concurrently.

Service SingleHostSpeculation implements Interface IApplication
{
    Service Instance inst = null;

    Struct StructWrappedSwitch s1 = null;
    Struct StructWrappedSwitch s2 = null;

    TVar TrueFalse s1_last_added = False;
    TVar TrueFalse s2_last_added = False;

    Map(from: Text, to: TrueFalse) added_map;

    TVar Map(from: Text, to: Struct StructWrappedSwitch) switch_map = null;
    
    // @Override --- from IApplication interface
    init(Service Instance inst_,
        TVar Map(from: Text, to: Struct StructWrappedSwitch) switch_map_)
    {
        inst = inst_;

        switch_map = switch_map_;
        atomically
        {
            Number counter = 0;
            for (Text switch_id in switch_map_)
            {
                added_map.set(switch_id,False);
                Struct StructWrappedSwitch tmp = switch_map_.get(switch_id);
                if (s1 == null)
                    s1 = tmp;
                else
                {
                    s2 = tmp;
                }
            }
        }
        
        if ((s1 == null) or (s2 == null))
        {
            print ('\n\n\n\nMASSIVE ERROR: Must have at least two ');
            print ('switches to run speculation test.\n\n\n');
        }
    }

    // @Override --- do nothing when first installed
    run(){}

    load_entry_all_switches()
    {
        for( Text switch_id in switch_map)
        {
            Struct StructWrappedSwitch sws = switch_map.get(switch_id);
            add_entry_switch(sws);
        }
    }
    some_event(Text read_switch_id, Text write_switch_id)
    {
        Struct StructWrappedSwitch to_read_from =
            switch_map.get(read_switch_id);
        Struct StructWrappedSwitch to_write_to =
            switch_map.get(write_switch_id);

        TrueFalse add_entry = added_map.get(write_switch_id);
        read_and_write(to_read_from,to_write_to, not add_entry);
        added_map.set(write_switch_id,not add_entry);
    }
    
    
    load_entry_both_switches()
    {
        add_entry_switch(s1);
        add_entry_switch(s2);
    }
    
    
    // called from external code
    event_1()
    {
        read_and_write(s1,s2,not s2_last_added);
        s2_last_added = not s2_last_added;
    }
    // called from external code
    event_2()
    {
        read_and_write(s2,s1, not s1_last_added);
        s1_last_added = not s1_last_added;
    }

    // Note: private to service
    read_and_write(
        Struct StructWrappedSwitch to_read_on,
        Struct StructWrappedSwitch to_write_to,
        TrueFalse add_entry)
    {
        atomically
        {
            to_read_on.wrapped_switch.ftable_size();
            if (add_entry)
                add_entry_switch(to_write_to);
            else
                remove_entry_switch(to_write_to);
        }
    }
    // Note: private to service
    add_entry_switch(Struct StructWrappedSwitch to_add_to)
    {
        Struct FlowTableEntry to_add;
        to_add.src_ip = '18.18.18.18';
        to_add.dst_ip = '18.18.18.19';
        // drop all packets
        to_add.action = '';
        
        atomically
        {
            to_add_to.wrapped_switch.add_entry(to_add);
        }
    }
    // Note: private to service
    remove_entry_switch(Struct StructWrappedSwitch to_remove_from)
    {
        atomically
        {
            to_remove_from.wrapped_switch.remove_entry(0);
        }
    }    
}

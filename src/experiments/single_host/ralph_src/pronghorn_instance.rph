alias Struct RoutingTableEntry as 'pronghorn.RTable.RoutingTableEntry';
alias Struct Switch as 'pronghorn.SwitchJava.Switch';
alias Struct Port as 'pronghorn.PortJava.Port';
alias Endpoint PronghornConnection as 'single_host.JavaPronghornConnection.PronghornConnection';

Struct RoutingTableEntry
{
    TVar TrueFalse active;
    // ipv4 addresses specified as a.b.c.d
    TVar Text src_ip;
    TVar Text dst_ip;
    // See
    // http://www.openflowhub.org/display/floodlightcontroller/Static+Flow+Pusher+API+%28New%29
    // for list of supported actions.    
    TVar Text action;    
}


Struct Port
{
    // Not making these tvars because expectation is that these are
    // write-once variables.
    Text local_switch_id;
    Number local_port_number;

    Text remote_switch_id;
    Number remote_port_number;

    
    // User's modulating bringing the link between two switches down
    // or bring it up.  True if port is up, false if it is not.
    TVar TrueFalse port_up;

    // If have two, connected switches join the network
    // simultaneously, then when one comes up it will announce all of
    // its ports, including a connection to a switch that does not yet
    // exist in the network.  In this case, user should not be able to
    // change any of the port's 
    TVar TrueFalse other_end_available;
}

Struct Switch
{
    // unique id for each switch
    TVar Text switch_id;    
    TVar Number available_capacity;
    TVar List (element: Struct RoutingTableEntry) rtable;

    // Indices are port numbers on local switch
    TVar Map (from: Number, to: Struct Port) all_ports;
    // Ports link two switches.  available ports is a map of ports
    // that the other end of the port exists for.  (Example of a case
    // where other end does not exist: added multiple switches to the
    // network simultaneously.)
    TVar Map (from: Number, to: Struct Port) available_ports;
}


Struct ConnectionWrapper
{
    Endpoint PronghornConnection child;
}


Endpoint PronghornInstance
{
    TVar Map(from: Text, to: Struct Switch) instance_switches;

    TVar Number coarse_lock_simulator = 0;

    TVar List(element : Struct ConnectionWrapper) children;

    Text last_added_switch_id;

    add_child_connection(Endpoint PronghornConnection new_child)
    {
        Struct ConnectionWrapper wrapper;
        wrapper.child = new_child;
        children.append(wrapper);
    }
    
    add_switch(Struct Switch new_switch)
    {
        Text switch_id = new_switch.switch_id;
	instance_switches.set(switch_id,new_switch);
        last_added_switch_id = switch_id;
    }
    
    switch_failure(Text switch_id)
    {
	instance_switches.remove(switch_id);
    }

    num_switches() returns Number
    {
        return instance_switches.size();
    }

    process_port_updates(List(element: Struct Port) port_updates)
    {
        print ('\nI received port updates\n');
    }

    
    

    single_op_and_ask_children_for_single_op()
    {
        atomically {
            for (Text switch_id in instance_switches)
                single_op(switch_id);

            for (Struct ConnectionWrapper wrapper in children)
            {
                Endpoint PronghornConnection endpt = wrapper.child;
                endpt.single_op_and_ask_children_for_single_op();
            }
        }
    }

    single_op_and_ask_children_for_single_op_switch_id(Text switch_id)
    {
        atomically {
            single_op(switch_id);

            for (Struct ConnectionWrapper wrapper in children)
            {
                Endpoint PronghornConnection endpt = wrapper.child;
                endpt.single_op_and_ask_children_for_single_op_switch_id(switch_id);
            }
        }
    }

    read_first_instance_routing_table()
    {
        atomically {
            Struct Switch target_switch =
                instance_switches.get(last_added_switch_id);
            target_switch.rtable.size();
        }        
    }
    
    remove_entry_on_last_switch()
    {
        atomically {
            Struct Switch target_switch =
                instance_switches.get(last_added_switch_id);
            target_switch.rtable.remove(0);
        }
    }

    insert_entry_on_last_switch()
    {
        Struct RoutingTableEntry to_add;
        to_add.active = True;
        to_add.src_ip = '20.30.13.1';
        to_add.dst_ip = '18.18.18.19';
        // drop all packets
        to_add.action = '';

        atomically {
            Struct Switch target_switch =
                instance_switches.get(last_added_switch_id);
            target_switch.rtable.append(to_add);            
        }
    }
    
    insert_entry_on_all_switches_and_partners(Text ip_src)
    {
        atomically
        {
            insert_entry_on_all_switches(ip_src);

            for (Struct ConnectionWrapper wrapper in children)
            {
                Endpoint PronghornConnection endpt = wrapper.child;
                endpt.insert_entry_on_all_switches_and_partners(ip_src);
            }
        }
    }
    

    
    
    insert_entry_on_all_switches(Text ip_src)
    {
        atomically
        {
            for (Text switch_id in instance_switches)
            {
                Struct Switch target_switch =
                    instance_switches.get(switch_id);
                Struct RoutingTableEntry to_add;
                to_add.active = True;
                to_add.src_ip = ip_src;
                to_add.dst_ip = '18.18.18.19';
                // drop all packets
                to_add.action = '';
                target_switch.rtable.append(to_add);
            }
        }
    }
    
    list_switch_ids() returns List(element:Text)
    {
        List(element: Text) switch_ids;
        for (Text switch_id in instance_switches)
            switch_ids.append(switch_id);
        return switch_ids;
    }
    
    logical_clear_switch_do_not_flush_clear_to_hardware()
    {
        for (Text switch_id in instance_switches)
        {
            Struct Switch target_switch = instance_switches.get(switch_id);
            // note: clearing an rtable does not actually push commands to
            // switches.  This was a bug, but now we're taking advantage of it.
            target_switch.rtable.clear();
        }
    }

    /**
       Because write to coarse_lock_simulator, cannot parallelize method.
     */
    single_op_coarse(Text switch_id) returns TrueFalse
    {
        TrueFalse had_switch = False;
        atomically {
            coarse_lock_simulator = coarse_lock_simulator + 1;
            if (instance_switches.contains(switch_id))
            {
                had_switch = True;
                Struct Switch target_switch = instance_switches.get(switch_id);
                if (target_switch.rtable.size() != 0)
                {
                    target_switch.rtable.remove(0);
                    //target_switch.rtable.clear();
                }
                else
                {
                    Struct RoutingTableEntry to_add;
                    to_add.active = True;
                    to_add.src_ip = '18.18.18.18';
                    to_add.dst_ip = '18.18.18.19';
                    // drop all packets
                    to_add.action = '';
                    target_switch.rtable.append(to_add);
                }
            }
            else
                had_switch = False;
        }
        return had_switch;
    }
    
    /**
       If have a switch corresponding to switch_id, then 
     */
    single_op(Text switch_id) returns TrueFalse
    {
        TrueFalse had_switch = False;
        atomically {
            if (instance_switches.contains(switch_id))
            {
                had_switch = True;
                Struct Switch target_switch = instance_switches.get(switch_id);
                if (target_switch.rtable.size() != 0)
                {
                    target_switch.rtable.remove(0);
                    //target_switch.rtable.clear();
                }
                else
                {
                    Struct RoutingTableEntry to_add;
                    to_add.active = True;
                    to_add.src_ip = '18.18.18.18';
                    to_add.dst_ip = '18.18.18.19';
                    // drop all packets
                    to_add.action = '';
                    target_switch.rtable.append(to_add);
                }
            }
            else
                had_switch = False;
        }
        return had_switch;
    }

    called_only_by_partner_single_op()
    {
        // for each switch connected to us, run single_op on it.  Should only be
        // called from a partner message
        for (Text switch_id in instance_switches)
        {
            Struct Switch target_switch = instance_switches.get(switch_id);
            if (target_switch.rtable.size() != 0)
            {
                target_switch.rtable.remove(0);
                //target_switch.rtable.clear();
            }
            else
            {
                Struct RoutingTableEntry to_add;
                to_add.active = True;
                to_add.src_ip = '18.18.18.18';
                to_add.dst_ip = '18.18.18.19';
                // drop all packets
                to_add.action = '';
                target_switch.rtable.append(to_add);
            }
        }
    }

    single_op_and_partner()
    {
        // Ask partner to perform action and
        
        atomically
        {
            @partner.called_only_by_partner_single_op();
            for (Text switch_id in instance_switches)
            {
                Struct Switch target_switch = instance_switches.get(switch_id);
                if (target_switch.rtable.size() != 0)
                {
                    target_switch.rtable.remove(0);
                    //target_switch.rtable.clear();
                }
                else
                {
                    Struct RoutingTableEntry to_add;
                    to_add.active = True;
                    to_add.src_ip = '18.18.18.18';
                    to_add.dst_ip = '18.18.18.19';
                    // drop all packets
                    to_add.action = '';
                    target_switch.rtable.append(to_add);
                }
            }
        }
    }
    
    
    
    
    block_traffic_all_switches(Text src_ip, Text dst_ip)
    {
        atomically
        {
            for (Text switch_id in instance_switches)
            {
                Struct Switch switch_to_add_to = instance_switches.get(switch_id);

                Struct RoutingTableEntry to_add;
                to_add.active = True;
                to_add.src_ip = src_ip;
                to_add.dst_ip = dst_ip;
                // send packet out all ports
                //to_add.action = 'output=flood';
                // drop packet
                to_add.action = '';
                
                switch_to_add_to.rtable.append(to_add);
            }
        }
    }

    remove_first_entry_all_switches()
    {
        atomically
        {
            for (Text switch_id in instance_switches)
            {
                Struct Switch switch_to_remove_from =
                    instance_switches.get(switch_id);
                if (switch_to_remove_from.rtable.size() > 0)
                    switch_to_remove_from.rtable.remove(0);
            }
        }
    }
}

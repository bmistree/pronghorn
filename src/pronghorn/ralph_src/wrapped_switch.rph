#include 'switch.rph'
alias Struct Switch as 'pronghorn.SwitchJava.Switch';
#include 'switch_delta.rph'
#include 'flow_table_entry.rph'
alias Struct FlowTableDelta as 'pronghorn.SwitchDeltaJava.FlowTableDelta';
alias Struct FlowTableEntry as 'pronghorn.FTable.FlowTableEntry';

alias Service FlowTableUtil as 'pronghorn.FTable.FlowTableUtil';
alias Service WrappedSwitch as 'pronghorn.WrappedSwitchJava.WrappedSwitch';

#include 'port_stats.rph'
alias Struct PortStats as 'pronghorn.PortStatsJava.PortStats';

#include 'access_control.rph'
alias Struct AccessControl as 'pronghorn.AccessControlJava.AccessControl';

Struct StructWrappedSwitch
{
    Service WrappedSwitch wrapped_switch = null;
}


Service WrappedSwitch
{
    Struct Switch wrapped_switch = null;
    Service FlowTableUtil ft_util = null;

    // Applications interact with a wrapped switch.  access_control should be
    // checked to ensure operations application makes are valid.
    Struct AccessControl access_control = null;

    // called by root instance only.  
    init(
        Struct Switch wrapped_switch_, Service FlowTableUtil ft_util_,
        Struct AccessControl access_control_)
    {
        wrapped_switch = wrapped_switch_;
        ft_util = ft_util_;
        access_control = access_control_;
    }
    // called by root instance only
    get_switch() returns Struct Switch
    {
        return wrapped_switch;
    }
    

    id () returns Text
    {
        return wrapped_switch.switch_id;
    }
    
    ftable_size() returns Number
    {
        read_lock_switch();
        return wrapped_switch.ftable.size();
    }

    // called by system only
    update_port_stats(Number port_num, Struct PortStats new_stats)
    {
        Struct PortStats old_stats = wrapped_switch.port_stats.get(port_num);
        if (old_stats != null)
        {
            new_stats.delta_rx_packets = difference_with_wrap_around(
                new_stats.rx_packets,old_stats.rx_packets);
            new_stats.delta_tx_packets = difference_with_wrap_around(
                new_stats.tx_packets,old_stats.tx_packets);
            new_stats.delta_rx_bytes = difference_with_wrap_around(
                new_stats.rx_bytes,old_stats.rx_bytes);
            new_stats.delta_tx_bytes = difference_with_wrap_around(
                new_stats.tx_bytes,old_stats.tx_bytes);
            new_stats.delta_rx_dropped = difference_with_wrap_around(
                new_stats.rx_dropped,old_stats.rx_dropped);
            new_stats.delta_tx_dropped = difference_with_wrap_around(
                new_stats.tx_dropped,old_stats.tx_dropped);
            new_stats.delta_rx_errors = difference_with_wrap_around(
                new_stats.rx_errors,old_stats.rx_errors);
            new_stats.delta_tx_errors = difference_with_wrap_around(
                new_stats.tx_errors,old_stats.tx_errors);
            new_stats.delta_rx_frame_err = difference_with_wrap_around(
                new_stats.rx_frame_err,old_stats.rx_frame_err);
        }
        wrapped_switch.port_stats.set(port_num,new_stats);
    }

    /**
       @param {Number} a --- 64 bit int
       @param {Number} b --- 64 bit int

       @returns {Number} --- a-b. Note that because of wraparound, b may be >
       a.  We *should* handle this case, but for now, in that case, we just
       return a.
     */
    difference_with_wrap_around(Number a, Number b) returns Number
    {
        // FIXME: actually handle wraparound correctly
        if (a < b)
            return a;
        
        return a - b;
    }
    
    // should only be called from within WrappedSwitch service.  Assumption is
    // that it is being called from within an atomically statement.  Otherwise,
    // write lock doesn't do anything.
    write_lock_switch()
    {
        // acquires switch lock by writing to tvar.  note: not incrementing
        // value here because that requires acquiring a read lock first.
        // semantics of lock manager are such that if many wait for read lock,
        // then they all get scheduled when a writer releases.  This is a
        // problem if the very next thing that they do is to all try to acquire
        // write locks: one of them will win and all the others will be fully
        // rolled back.
        wrapped_switch.delta.switch_lock = 5;
    }

    // should only be called from within WrappedSwitch service.  Assumption is
    // that it is being called from within an atomically statement.  Otherwise,
    // read lock doesn't do anything.
    read_lock_switch()
    {
        wrapped_switch.delta.switch_lock;
    }
    
    add_entry(Struct FlowTableEntry to_add) returns TrueFalse
    {
        Struct FlowTableEntry copied_to_add = ft_util.copy_entry(to_add);
        Struct FlowTableDelta ftd;

        // check allowed to add this entry
        TrueFalse permissions_allowed = check_add_remove_permissions(to_add);
        if (not permissions_allowed)
            return False;
        
        atomically
        {
            write_lock_switch();
            ftd.inserted = True;
            ftd.entry = copied_to_add;
            ftd.index = wrapped_switch.ftable.size();
            wrapped_switch.ftable.append(copied_to_add);
            
            // FIXME: should filter adds then removes or removes then adds
            wrapped_switch.delta.ft_deltas.append(ftd);
        }
        return True;
    }

    remove_entry(Number index_to_remove_from) returns TrueFalse
    {
        Struct FlowTableDelta ftd;
        atomically
        {
            write_lock_switch();

            ftd.index = index_to_remove_from;
            ftd.inserted = False;
            ftd.entry =
                wrapped_switch.ftable.get(index_to_remove_from);

            // check allowed to remove this entry
            TrueFalse permissions_allowed =
                check_add_remove_permissions(ftd.entry);
            if (not permissions_allowed)
                return False;

            // actually perform remove
            wrapped_switch.ftable.remove(index_to_remove_from);

            // FIXME: should filter adds then removes or removes then adds
            wrapped_switch.delta.ft_deltas.append(ftd);
        }
        return True;
    }

    check_add_remove_permissions(Struct FlowTableEntry ft_entry)
        returns TrueFalse
    {
        // check access control here
        if (not access_control.allow_writes)
            return False;

        // first check whitelist: only allowed to remove entries in whitelist
        if (access_control.whitelist_ip_src_write_list != null)
        {
            if (not in_helper(ft_entry.src_ip, access_control.whitelist_ip_src_write_list))
                return False;
        }
        if (access_control.whitelist_ip_dst_write_list != null)
        {
            if (not in_helper(ft_entry.dst_ip,access_control.whitelist_ip_dst_write_list))
                return False;
        }
        // check blacklist: not allowed to remove entries in blacklist
        if (access_control.blacklist_ip_src_write_list != null)
        {
            if (not in_helper(ft_entry.src_ip,access_control.blacklist_ip_src_write_list))
                return False;
        }
        if (access_control.blacklist_ip_dst_write_list != null)
        {
            if (not in_helper(ft_entry.dst_ip, access_control.blacklist_ip_dst_write_list))
                return False;
        }
        return True;
    }
    
    /**
       Substitute method for in operator, which is currently not supported on
       lists.
     */
    in_helper(Text needle, List(element: Text) haystack) returns TrueFalse
    {
        for (Text item in haystack)
        {
            if (needle == item)
                return True;
        }
        return False;
    }
    
    
    get_entry (Number index) returns Struct FlowTableEntry
    {
        read_lock_switch();
        Struct FlowTableEntry entry = wrapped_switch.ftable.get(index);
        return ft_util.copy_entry(entry);
    }


    /**
       FIXME: Should eventually remove.  Only using this method as a simple hook
       for ordering tests.  General idea is that test uses an out-of-band
       mechanism to clear flow tables on switches and we need to also clear
       logical flow tables (without pushing these clears to switches).  Use this
       method to do so.
     */
    logical_clear_switch_do_not_flush_clear_to_hardware()
    {
        wrapped_switch.ftable.clear();
        wrapped_switch.delta.ft_deltas.clear();
    }
}

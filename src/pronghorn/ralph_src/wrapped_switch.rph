#include 'switch.rph'
alias Struct Switch as 'pronghorn.SwitchJava.Switch';
#include 'switch_delta.rph'
#include 'flow_table_entry.rph'
alias Struct FlowTableDelta as 'pronghorn.SwitchDeltaJava.FlowTableDelta';
alias Struct FlowTableEntry as 'pronghorn.FTable.FlowTableEntry';

alias Service FlowTableUtil as 'pronghorn.FTable.FlowTableUtil';
alias Service WrappedSwitch as 'pronghorn.WrappedSwitchJava.WrappedSwitch';

#include 'port_stats.rph'
alias Struct PortStats as 'pronghorn.PortStatsJava.PortStats';

Struct StructWrappedSwitch
{
    Service WrappedSwitch wrapped_switch = null;
}


Service WrappedSwitch
{
    Struct Switch wrapped_switch = null;
    Service FlowTableUtil ft_util = null;

    init(Struct Switch wrapped_switch_, Service FlowTableUtil ft_util_)
    {
        wrapped_switch = wrapped_switch_;
        ft_util = ft_util_;
    }

    id () returns Text
    {
        return wrapped_switch.switch_id;
    }
    
    ftable_size() returns Number
    {
        read_lock_switch();
        return wrapped_switch.ftable.size();
    }

    update_port_stats(Number port_num, Struct PortStats new_stats)
    {
        Struct PortStats old_stats = wrapped_switch.port_stats.get(port_num);
        if (old_stats != null)
        {
            new_stats.delta_rx_packets = difference_with_wrap_around(
                new_stats.rx_packets,old_stats.rx_packets);
            new_stats.delta_tx_packets = difference_with_wrap_around(
                new_stats.tx_packets,old_stats.tx_packets);
            new_stats.delta_rx_bytes = difference_with_wrap_around(
                new_stats.rx_bytes,old_stats.rx_bytes);
            new_stats.delta_tx_bytes = difference_with_wrap_around(
                new_stats.tx_bytes,old_stats.tx_bytes);
            new_stats.delta_rx_dropped = difference_with_wrap_around(
                new_stats.rx_dropped,old_stats.rx_dropped);
            new_stats.delta_tx_dropped = difference_with_wrap_around(
                new_stats.tx_dropped,old_stats.tx_dropped);
            new_stats.delta_rx_errors = difference_with_wrap_around(
                new_stats.rx_errors,old_stats.rx_errors);
            new_stats.delta_tx_errors = difference_with_wrap_around(
                new_stats.tx_errors,old_stats.tx_errors);
            new_stats.delta_rx_frame_err = difference_with_wrap_around(
                new_stats.rx_frame_err,old_stats.rx_frame_err);
        }
        wrapped_switch.port_stats.set(port_num,new_stats);
    }

    /**
       @param {Number} a --- 64 bit int
       @param {Number} b --- 64 bit int

       @returns {Number} --- a-b. Note that because of wraparound, b may be >
       a.  We *should* handle this case, but for now, in that case, we just
       return a.
     */
    difference_with_wrap_around(Number a, Number b) returns Number
    {
        // FIXME: actually handle wraparound correctly
        if (a < b)
            return a;
        
        return a - b;
    }
    
    // should only be called from within WrappedSwitch service.  Assumption is
    // that it is being called from within an atomically statement.  Otherwise,
    // write lock doesn't do anything.
    write_lock_switch()
    {
        // acquires switch lock by writing to tvar.  note: not incrementing
        // value here because that requires acquiring a read lock first.
        // semantics of lock manager are such that if many wait for read lock,
        // then they all get scheduled when a writer releases.  This is a
        // problem if the very next thing that they do is to all try to acquire
        // write locks: one of them will win and all the others will be fully
        // rolled back.
        wrapped_switch.delta.switch_lock = 5;
    }

    // should only be called from within WrappedSwitch service.  Assumption is
    // that it is being called from within an atomically statement.  Otherwise,
    // read lock doesn't do anything.
    read_lock_switch()
    {
        wrapped_switch.delta.switch_lock;
    }
    
    add_entry(Struct FlowTableEntry to_add)
    {
        Struct FlowTableEntry copied_to_add = ft_util.copy_entry(to_add);
        Struct FlowTableDelta ftd;

        atomically
        {
            write_lock_switch();
            ftd.inserted = True;
            ftd.entry = copied_to_add;
            ftd.index = wrapped_switch.ftable.size();
            wrapped_switch.ftable.append(copied_to_add);
            
            // FIXME: should filter adds then removes or removes then adds
            wrapped_switch.delta.ft_deltas.append(ftd);
        }
    }

    remove_entry(Number index_to_remove_from)
    {
        Struct FlowTableDelta ftd;
        atomically
        {
            write_lock_switch();

            ftd.index = index_to_remove_from;
            ftd.inserted = False;
            ftd.entry =
                wrapped_switch.ftable.get(index_to_remove_from);
            wrapped_switch.ftable.remove(index_to_remove_from);

            // FIXME: should filter adds then removes or removes then adds
            wrapped_switch.delta.ft_deltas.append(ftd);
        }
    }

    get_entry (Number index) returns Struct FlowTableEntry
    {
        read_lock_switch();
        Struct FlowTableEntry entry = wrapped_switch.ftable.get(index);
        return ft_util.copy_entry(entry);
    }


    /**
       FIXME: Should eventually remove.  Only using this method as a simple hook
       for ordering tests.  General idea is that test uses an out-of-band
       mechanism to clear flow tables on switches and we need to also clear
       logical flow tables (without pushing these clears to switches).  Use this
       method to do so.
     */
    logical_clear_switch_do_not_flush_clear_to_hardware()
    {
        wrapped_switch.ftable.clear();
        wrapped_switch.delta.ft_deltas.clear();
    }
}
